Task 9.2 — Canonical sticky sequence (identical for both ends of the same cut)
Create `DigestCore/Sources/DigestCore/Overhangs.swift` with parity to your Python:

- `overhangLength(site: String, cutIndexTop: Int) -> Int`
- `sliceCircular(_ s: [Character], start: Int, end: Int) -> String` (char-array version)
- `canonicalSticky(seq: String, cutPos: Int, recognitionSite: String, cutIndexTop: Int, overhangType: OverhangType, circular: Bool) -> String`

import Foundation

public func overhangLength(site: String, cutIndexTop: Int) -> Int {
    // Python: abs(2*cut_index - site_len)
    let L = site.count
    return abs(2*cutIndexTop - L)
}

private func sliceCircular(_ arr: [Character], _ start: Int, _ end: Int) -> String {
    let n = arr.count
    precondition(n > 0)
    let len = (end - start >= 0) ? (end - start) : (n - start + end)
    return String((0..<len).map { arr[(start + $0 + n) % n] })
}

/// Returns the CANONICAL 5'→3' overhang sequence for the ligating protrusion,
/// same for both the left- and right-end created by this cut.
/// 5' overhang: take bases AFTER the cut (cutPos .. cutPos+k)
/// 3' overhang: take bases BEFORE the cut (cutPos-k .. cutPos)
public func canonicalSticky(seq: String,
                            cutPos: Int,
                            recognitionSite: String,
                            cutIndexTop: Int,
                            overhangType: OverhangType,
                            circular: Bool) -> String {
    let k = overhangLength(site: recognitionSite, cutIndexTop: cutIndexTop)
    if k == 0 || overhangType == .blunt { return "" }

    let arr = Array(seq.uppercased())
    let n = arr.count
    guard n > 0 else { return "" }

    if overhangType == .fivePrime {
        let start = cutPos
        let end   = cutPos + k
        if circular { return sliceCircular(arr, start, end) }
        let s = max(0, min(start, n)), e = max(0, min(end, n))
        return String(arr[s..<e])
    } else if overhangType == .threePrime {
        let start = cutPos - k
        let end   = cutPos
        if circular { return sliceCircular(arr, start, end) }
        let s = max(0, min(start, n)), e = max(0, min(end, n))
        return s < e ? String(arr[s..<e]) : ""
    } else {
        return ""
    }
}


Checkpoint: Build.