Task 3.1 â€” DigestEngine skeleton
Create `DigestCore/Sources/DigestCore/DigestEngine.swift` implementing:
- init(sequence:enzymes:)
- `cutSites()` (linear search using findAllMatches)
- `digest(options:)` handling linear and circular
- helper `sliceCircular`
Keep overhang computation as TODO for now (use `.unknown`).

import Foundation

public struct DigestOptions {
    public let circular: Bool
    public let returnSequences: Bool
    public init(circular: Bool = false, returnSequences: Bool = false) {
        self.circular = circular; self.returnSequences = returnSequences
    }
}

public final class DigestEngine {
    let sequence: String
    let enzymes: [Enzyme]
    public init(sequence: String, enzymes: [Enzyme]) {
        self.sequence = sequence.uppercased()
        self.enzymes = enzymes
    }

    public func cutSites() -> [CutSite] {
        var sites: [CutSite] = []
        for e in enzymes {
            let hits = findAllMatches(sequence: sequence, motifIUPAC: e.site)
            for start in hits {
                if let top = e.cutIndexTop { sites.append(.init(enzyme: e, position: start + top, strand: .top)) }
                if let bot = e.cutIndexBottom { sites.append(.init(enzyme: e, position: start + bot, strand: .bottom)) }
            }
        }
        let uniq = Array(Set(sites))
        return uniq.sorted { $0.position < $1.position }
    }

    public func digest(options: DigestOptions) -> [Fragment] {
        let n = sequence.count
        let cuts = cutSites().map(\.position).sorted()
        guard !cuts.isEmpty else {
            return [Fragment(
                start: 0, end: n, length: n,
                leftEnd: .init(overhangType: .unknown, overhangSeq5to3: nil, sourceEnzyme: nil),
                rightEnd: .init(overhangType: .unknown, overhangSeq5to3: nil, sourceEnzyme: nil),
                sequence: options.returnSequences ? sequence : nil
            )]
        }

        var frags: [Fragment] = []
        if options.circular {
            let extended = cuts + [cuts.first! + n]
            for k in 0..<extended.count-1 {
                let a = extended[k]
                let b = extended[k+1]
                let start = a % n
                let end = b % n
                let len = end >= start ? (end - start) : (n - start + end)
                frags.append(Fragment(
                    start: start, end: end, length: len,
                    leftEnd: .init(overhangType: .unknown, overhangSeq5to3: nil, sourceEnzyme: nil),
                    rightEnd: .init(overhangType: .unknown, overhangSeq5to3: nil, sourceEnzyme: nil),
                    sequence: options.returnSequences ? sliceCircular(sequence, start, len) : nil
                ))
            }
        } else {
            let indices = [0] + cuts + [n]
            for i in 0..<indices.count-1 {
                let start = indices[i]
                let end = indices[i+1]
                frags.append(Fragment(
                    start: start, end: end, length: end - start,
                    leftEnd: .init(overhangType: .unknown, overhangSeq5to3: nil, sourceEnzyme: nil),
                    rightEnd: .init(overhangType: .unknown, overhangSeq5to3: nil, sourceEnzyme: nil),
                    sequence: options.returnSequences ? String(Array(sequence)[start..<end]) : nil
                ))
            }
        }
        return frags
    }
}

private func sliceCircular(_ s: String, _ start: Int, _ length: Int) -> String {
    let n = s.count; let arr = Array(s)
    return String((0..<length).map { arr[(start + $0) % n] })
}


Checkpoint: Package builds.