Goal: Implement Ferguson plots in GelLayout and preserve the existing y(...) signature used by GelRenderView.

Apply to: Sources/Features/Gel/GelLayout.swift (or wherever GelLayout.swift lives).

Actions: Replace the current contents with this implementation. Keep the file name the same.

// GelLayout.swift
import Foundation
import CoreGraphics

/// Physics-ish gel mobility utilities using a Ferguson model.
/// log(mu(C)) = log(mu0(bp)) - K(bp) * C
/// We normalize mobility across [minBP, maxBP] to an Rf in [0,1] and map to pixels.
public enum GelLayout {

    // ---- Tunables (visual → calibrate later with real ladders) ----
    // Zero-gel baseline mobility ~ A * bp^(-alpha)
    private static let A: Double = 1.10
    private static let alpha: Double = 0.48

    // Retardation coefficient K(bp) ~ k0 + k1 * log10(bp)
    private static let k0: Double = -0.05
    private static let k1: Double =  0.22

    // MARK: - Ferguson helpers

    public static func mu0(bp: Int) -> Double {
        let b = max(1, bp)
        return A * pow(Double(b), -alpha)
    }

    public static func K(bp: Int) -> Double {
        let b = max(1, bp)
        return k0 + k1 * log10(Double(b))
    }

    /// Mobility at gel percentage C (e.g., 1.0, 2.0, 3.0).
    public static func mobility(bp: Int, gelPercent C: Double) -> Double {
        mu0(bp: bp) * exp(-K(bp: bp) * max(0.0, C))
    }

    /// Map bp → y using Ferguson mobility normalized to [0,1] within [minBP,maxBP].
    /// Larger fragments (bp↑) end up nearer the top (y closer to `top`).
    public static func y(bp: Int, minBP: Int, maxBP: Int,
                         top: CGFloat, height: CGFloat, gelPercent: Double) -> CGFloat
    {
        let lo = min(minBP, maxBP)
        let hi = max(minBP, maxBP)

        // Sample mobilities across the range for normalization
        let step = max(1, (hi - lo) / 18)
        let sample = stride(from: lo, through: hi, by: step).map { mobility(bp: $0, gelPercent: gelPercent) }

        guard let mMin = sample.min(), let mMax = sample.max(), mMax > mMin else {
            return top + height // fallback if degenerate range
        }

        let mu = mobility(bp: bp, gelPercent: gelPercent)
        let Rf = (mu - mMin) / (mMax - mMin) // 0..1 -> bottom
        return top + (1 - CGFloat(Rf)) * height
    }
}


Why this is safe: GelRenderView already calls GelLayout.y(...) and passes gelPercent, so you don’t have to touch UI code.